class Paletteron{static MAX_COLORS_AMOUNT=16777216;static MAX_COLORS_SPACE_DISTANCE=443.405;constructor(t,e,r){if(t&&(t<0||t>1))throw new Error("Scale must be between 0 and 1.");if(e&&(e<1||e>Paletteron.MAX_COLORS_AMOUNT))throw new Error(`Colors to pick must be between 1 and ${Paletteron.MAX_COLORS_AMOUNT}.`);if(r&&(r<0||r>1))throw new Error("Min coverage must be between 0 and 1.");this.scale=t||.2,this.colorsToPick=e||5,this.minCoverage=r||.001}getPalette(t,e=!1){e&&(t.crossOrigin="anonymous");const[r,o]=this.downscale(t),n=this.extractPixels(o),a=this.flattenColors(n),s=this.bundleColors(a),l=this.removeLowCoverageColors(s),c=this.calculateScore(l),i=this.finalizeColors(c);return r.remove(),i}printDebuggingPalette(t,e){e.innerHTML="";for(const r of t){const t=document.createElement("div");t.style.backgroundColor=`rgb(${r[0]}, ${r[1]}, ${r[2]})`;const o=document.createTextNode(`rgb(${r[0]}, ${r[1]}, ${r[2]})`);t.appendChild(o),e.appendChild(t)}}downscale(t){const e=t.width*this.scale,r=t.height*this.scale,o=document.createElement("canvas");o.width=e,o.height=r;const n=o.getContext("2d");return n.drawImage(t,0,0,e,r),document.body.appendChild(o),o.style.position="fixed",o.style.top="9999px",o.style.left="9999px",[o,n]}extractPixels(t){const e=new Array(256).fill(0).map((()=>new Array(256).fill(0).map((()=>new Array(256).fill(0))))),r=t.getImageData(0,0,t.canvas.width,t.canvas.height);for(let t=0;t<r.data.length;t+=4){const o=r.data[t],n=r.data[t+1],a=r.data[t+2];e[o][n][a]++}return e}flattenColors(t){const e=[];for(let r=0;r<t.length;r++)for(let o=0;o<t[r].length;o++)for(let n=0;n<t[r][o].length;n++){const a=t[r][o][n];a>0&&e.push({r:r,g:o,b:n,amount:a,score:0})}return e}removeLowCoverageColors(t){const e=t.reduce(((t,e)=>t+e.amount),0)*this.minCoverage;return t.filter((t=>t.amount>=e))}findAverageColorDistance(t){let e=0,r=0;for(let o=0;o<t.length;o++)for(let n=o+1;n<t.length;n++)e+=this.calculateDistance([t[o].r,t[o].g,t[o].b],[t[n].r,t[n].g,t[n].b]),r++;return e/r}bundleColors(t){t.sort(((t,e)=>e.amount-t.amount));const e=this.findAverageColorDistance(t);for(let r=0;r<t.length;r++)for(let o=r+1;o<t.length;o++)if(this.calculateDistance([t[r].r,t[r].g,t[r].b],[t[o].r,t[o].g,t[o].b])<e){const n=this.calculateDistance([t[r].r,t[r].g,t[r].b],[t[o].r,t[o].g,t[o].b])/e;t[r].amount+=t[o].amount*n,t.splice(o,1),o--}return t}calculateDistance(t,e){const r=t[0]-e[0],o=t[1]-e[1],n=t[2]-e[2];return Math.sqrt(r*r+o*o+n*n)}findColorsCenter(t,e){e||(e=t.length);let r=[0,0,0];for(let o=0;o<e;o++)r[0]+=t[o].r,r[1]+=t[o].g,r[2]+=t[o].b;return r[0]/=e,r[1]/=e,r[2]/=e,r}calculateAverageDistanceToCenter(t){const e=this.findColorsCenter(t);let r=0;for(const o of t)r+=this.calculateDistance([o.r,o.g,o.b],e);return r/t.length}calculateScore(t){const e=t.reduce(((t,e)=>t+e.amount),0),r=this.findColorsCenter(t),o=this.calculateAverageDistanceToCenter(t);for(const n of t)n.score+=n.amount/e,n.score+=this.calculateDistance([n.r,n.g,n.b],r)/o*Math.log(n.amount);return t.sort(((t,e)=>e.score-t.score)),t}finalizeColors(t){t.sort(((t,e)=>e.score-t.score));return(t=t.slice(0,this.colorsToPick)).map((t=>[t.r,t.g,t.b]))}}